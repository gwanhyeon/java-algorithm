package _2021.스터디.스터디_SNU.Section09;

/**
 * 1.문제풀이시간: 40분
 * 2.컴퓨팅사고
 * (1) 테두리부분에 가능한 모든 수의 합을 구합니다.
 *
 * 예를들어, {1,3,1},{1,5,1},{4,2,1}}의 수가 주어졌을때를 가정하겠습니다.
 * [1, 4, 5, 0]
 * [2, 0, 0, 0]
 * [6, 0, 0, 0]
 * [0, 0, 0, 0]
 *
 * 0,0값을 기준으로해서 오른쪽으로 구할 수 있는 모든 경우의 합을 계속 더해나갑니다.
 * 0,0값을 기준으로해서 아래쪽으로 구할 수 있는 모든 경우의 합을 계속 더해나갑니다.
 *
 * (2) 오른쪽,아래쪽으로 구할 수 있는 모든 경우의 sum이 구해진 경우이기 때문에 오른쪽,아래쪽의 값중 최솟값을 구해서 현재 진행될 값을 구해줍니다.
 *값
 * grid Arrays
 * [1, 3, 1]
 * [1, 5(더해야할값) , 1]
 * [4, 2, 1]
 * dp Arrays
 * [1, 4(오른쪽값), 5, 0]
 * [2(아랫쪽), 0, 0, 0]
 * [6, 0, 0, 0]
 * [0, 0, 0, 0]
 *
 * 해당값들이 주어졌을때, 0,0값을 기준으로 진행되었다고 할때, (4 오른쪽값 , 아랫쪽값 2)의 최솟값인 2의 값에서 현재 그리디값으로 주어진 5의 값과 더하면 현재까지 진행된 path의 sum의 값을 구할 수 있습니다.
 * 즉, (오른쪽값, 아랫쪽값)중에 최솟값을 구해서 현재 진행되야할 값(더해야할값)을 더해줍니다.
 *
 */
public class leetcode_Minimum_Path_Sum_kgh {
    public static void main(String[] args) {
        minPathSum(new int[][]{{1,3,1},{1,5,1},{4,2,1}});
        minPathSum(new int[][]{{1,2,3},{4,5,6}});
        //[1,2,3],[4,5,6]
    }
    static int minPathSum(int[][] grid) {

        int n = grid.length;
        int m = grid[0].length;

        int[][] dp = new int[n][m];
        dp[0][0] = grid[0][0];
        // 아래의 경우
        for(int i=1; i<n; i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        // 오른쪽의 경우
        for(int i=1; i<m; i++){
            dp[0][i] = dp[0][i-1] + grid[0][i];
        }

        for(int i=1; i<n; i++){
            for(int j=1; j<m; j++){
                // (오른쪽 더해진값, 아랫쪽더해진값) 최솟값 + 현재 진행되야할
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        System.out.println(dp[n-1][m-1]);
        return dp[n-1][m-1];
    }
}
