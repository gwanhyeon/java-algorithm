package 스터디.스터디_SNU.Section05;
/**
 * 1. 문제 풀이 시간: 20분
 * 2. 컴퓨팅사고
 * 주어진 m,n의 x,y의 맵의 범위만큼 테두리부분의 값을 모두 1로 만들어준다. 그 이유는 가는 경로는 하나씩의 최소값을 갖고있기때문입니다.
 * 그리고나서 대각선으로 교차되는 현재의 값끼리의 합은 갈 수 있는 경로의 개수를 만들 수 있습니다. 처음에 BFS나 DFS로 풀어야하지 않나 라고 생각했지만, 이 관련된 문제를 전에 풀어본 적이 있기 때문에 DP로 접근하려 하였습니다.
 *
 예를 들어 m=3, n=7의 경우를 생각해보면
 0 0 0 0 0 0 0
 0 0 0 0 0 0 0
 0 0 0 0 0 0 0

 1 1 1 1 1 1 1
 1 0 0 0 0 0 0
 1 0 0 0 0 0 0

 1 1 1 1  1  1  1
 1 2 3 4  5  6  7
 1 3 6 10 15 21 28

 다음과 같이 DP를 이루어내는것을 확인할 수 있습니다. 이 문제는 모든 경로를 찾는 문제일 수도 있으며, 최단 경로의 개수를 찾는 문제가 될 수 있습니다.
 여기서 응용을 하게 되면 m,n의 맵이 가지고 있는 범위 내에서 하나의 함정을 내서 갈 수 없는 경로를 추가시킬 수 있는 문제로 응용이 가능할 것으로 생각이 됩니다.

 3. 시간복잡도
 O(M*N)의 시간복잡도를 갖습니다. 1 <= m, n <= 100 의 범위를 갖게 되므로 O(100)으로 충분히 가능한 경우가 되게 됩니다. 이번 문제는 M,N의 범위가 작아서 완전탐색을 통해서도 가능할 것이라 판단되지만,
 범위가 조금만 높아지게 된다면 O(N^2)으로 처리할 수 없을 것으로 생각됩니다. 예를 들어, 10000 <= m, 10000 <= n과 같은 경우는 O(N)으로 풀어야하는 경우가 생기게 될 것입니다.
 */
public class leetcode_unique_paths_kgh {
    static int[][] dp;
    static int answer = 0;
    public static void main(String[] args) {
        uniquePaths(3,7);
    }
    static int uniquePaths(int m, int n) {
        dp = new int[m][n];
        dp[0][0] = 1;
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(i != 0){
                    dp[i][j] += dp[i-1][j];
                }
                if(j != 0){
                    dp[i][j] += dp[i][j-1];
                }
            }
        }
        System.out.println(dp[m-1][n-1]);
        return dp[m-1][n-1];
    }
}
